import{_ as e,c as t,o as a,a as o}from"./app.447407fd.js";const p=JSON.parse('{"title":"CS Education","description":"","frontmatter":{},"headers":[{"level":2,"title":"Teaching programming in the age of large LM based autocomplete","slug":"teaching-programming-in-the-age-of-large-lm-based-autocomplete"},{"level":2,"title":"A Rust-based curriculum for CS education (Honors track)","slug":"a-rust-based-curriculum-for-cs-education-honors-track"},{"level":2,"title":"Using Language Models to generate questions and activities suited to Adaptive learning for CS1,2,3","slug":"using-language-models-to-generate-questions-and-activities-suited-to-adaptive-learning-for-cs1-2-3"},{"level":2,"title":"A study of best practices and recommendations for asynchronously teaching CS1,2,3","slug":"a-study-of-best-practices-and-recommendations-for-asynchronously-teaching-cs1-2-3"},{"level":2,"title":"A mymind-like search for all course content, a study of its effects","slug":"a-mymind-like-search-for-all-course-content-a-study-of-its-effects"},{"level":2,"title":"Misc","slug":"misc"}],"relativePath":"cs_education.md","lastUpdated":null}'),i={name:"cs_education.md"},s=o('<h1 id="cs-education" tabindex="-1">CS Education <a class="header-anchor" href="#cs-education" aria-hidden="true">#</a></h1><h2 id="teaching-programming-in-the-age-of-large-lm-based-autocomplete" tabindex="-1">Teaching programming in the age of large LM based autocomplete <a class="header-anchor" href="#teaching-programming-in-the-age-of-large-lm-based-autocomplete" aria-hidden="true">#</a></h2><p>Large language model based autocomplete is a recent addition to IDEs (Copilot, CodeWhisperer, Codex). Copilot, for example, is good enough to implement entire operations in Data Structures based on their method name/documentation/comments.</p><p>The workflow is -</p><ol><li>Write a comment describing what needs to happen</li><li>Trigger autocomplete</li><li>Select the appropriate option</li><li>Modify if need be</li></ol><p>&quot;1.&quot; is done by the instructors generally. 3. and 4. are done by the students. In my experience 4. is only needed 10-30% of the time. As low as 0% for data structure assignments; on account of how common they are within the copilot training dataset.</p><p>So, 3. is where the student does most of the work. Selecting the appropriate option is very different from thinking up and writing code. It essentially turns a code writing assignment into a code reading comprehension assignment.</p><p>So that leads to some interesting questions:</p><ul><li>Is it better for the student that most introductory assignments are program reading comprehension instead of writing? <ul><li>If it&#39;s better, how can we adjust the curriculum or assessments to optimize for this?</li><li>If it&#39;s worse, how can we adjust the curriculum or assessments to avoid students using them?</li></ul></li></ul><h2 id="a-rust-based-curriculum-for-cs-education-honors-track" tabindex="-1">A Rust-based curriculum for CS education (Honors track) <a class="header-anchor" href="#a-rust-based-curriculum-for-cs-education-honors-track" aria-hidden="true">#</a></h2><p>A curriculum, surrounding tools (autograders, for visualization, etc.), policies, and assessment (, set of video lectures? Slides and video transcript as a textbook?) for honor&#39;s version of CS1,2,3 based on Rust.</p><p>Rust can be thought of as a modern C++, at the end of 1212 students might be working on Projects that look like this, while writing code as simple <a href="https://github.com/mikaelmello/inquire/blob/main/examples/expense_tracker.rs" target="_blank" rel="noreferrer">as this.</a> <img src="https://raw.githubusercontent.com/mikaelmello/inquire/main/assets/expense_tracker.gif" alt="Interactive application in Rust"></p><p>I don&#39;t want to make an argument for why Rust here, but the skeleton of the argument I am imagining is:</p><ul><li>Excellent modern error messages and documentation.</li><li>Designed with concurrent/parallel programming in mind.</li><li>Very consistent, explainable syntax.</li><li>Easy to go from Rust to Python/Javascript/C++ - three of the most used programming languages for courses after the introductory CS. I made a <a href="https://forms.gle/BYxheARrYfmoM4hh8" target="_blank" rel="noreferrer">Google Form</a> to help collect data to make my case, but I don&#39;t think it was ever sent out.</li><li>Low-level enough to properly teach data structures, computer architecture, parallel programming, etc. but also high-level enough for an easy and fun introduction to programming.</li><li>Modern build/packaging tools mean that students can be productive for personal projects independent of provided boilerplate.</li></ul><blockquote><p>I think the likelihood of this happening is very low, but I think it might be attractive to do as an Honor&#39;s version of the introductory CS courses, especially for students who&#39;ve already done well in AP CS.</p></blockquote><h2 id="using-language-models-to-generate-questions-and-activities-suited-to-adaptive-learning-for-cs1-2-3" tabindex="-1">Using Language Models to generate questions and activities suited to Adaptive learning for CS1,2,3 <a class="header-anchor" href="#using-language-models-to-generate-questions-and-activities-suited-to-adaptive-learning-for-cs1-2-3" aria-hidden="true">#</a></h2><h2 id="a-study-of-best-practices-and-recommendations-for-asynchronously-teaching-cs1-2-3" tabindex="-1">A study of best practices and recommendations for asynchronously teaching CS1,2,3 <a class="header-anchor" href="#a-study-of-best-practices-and-recommendations-for-asynchronously-teaching-cs1-2-3" aria-hidden="true">#</a></h2><h2 id="a-mymind-like-search-for-all-course-content-a-study-of-its-effects" tabindex="-1">A <a href="https://mymind.com/" target="_blank" rel="noreferrer">mymind</a>-like search for all course content, a study of its effects <a class="header-anchor" href="#a-mymind-like-search-for-all-course-content-a-study-of-its-effects" aria-hidden="true">#</a></h2><h2 id="misc" tabindex="-1">Misc <a class="header-anchor" href="#misc" aria-hidden="true">#</a></h2><ul><li>Microsoft also has a debug server protocol like their language server protocol. <ul><li>Making visual debuggers should be trivial for simple languages like java. <ul><li>See <a href="https://github.com/hediet/vscode-debug-visualizer" target="_blank" rel="noreferrer">https://github.com/hediet/vscode-debug-visualizer</a></li><li>The above doesn&#39;t work on any random Java code, but it&#39;s very easy to make it work for any Java code, especially if the visualization is displayed outside VSCode as a regular webpage</li></ul></li><li>We should also be able to use the debugger as a code comprehension assessment. As we step through the code... <ul><li>write down the correct value for each variable</li><li>or, select what happens from a list of options</li></ul></li></ul></li><li>There is a project that syncs slide PDFs with recorded videos, to make a webpage where you can see them side-by-side. Clicking on a certain slide will take you to the place in the video the slide first appeared. <ul><li>See <a href="https://github.com/hediet/slideo" target="_blank" rel="noreferrer">https://github.com/hediet/slideo</a></li><li>I think a version that outputs video chapter information that you can add to YouTube is much more practical, students can use that information to skip to the slide they&#39;re interested in.</li></ul></li><li>Generating subtitles from video lectures, to make the videos searchable. Searching for terms will return timestamps.</li><li>A REPL for common canvas operations, so we don&#39;t need to bother navigating canvas to do them. <ul><li>REPLs don&#39;t always have to be on a terminal, we can have maybe a Slack bot that lets us send commands to the REPL, and show us the output.</li><li>A transformer trained to go from natural language, describing what canvas operation we want to do, and generating the corresponding REPL command.</li></ul></li></ul>',20),r=[s];function n(l,c,d,u,h,m){return a(),t("div",null,r)}const f=e(i,[["render",n]]);export{p as __pageData,f as default};
